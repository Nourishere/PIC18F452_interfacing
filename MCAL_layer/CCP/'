/* 
 * File:   hal_ccp.c
 * Author: nour
 *
 * Created on July 23, 2025, 4:18 PM
 * @Brief: This source file contains the CCP module implementation.
 */
#include "hal_ccp.h"

/* The pin used in the ccp1 module */
pin_config_t CCP1_pin = {
	PORTC_I,
	PIN2,
	GPIO_OUT,	
	GPIO_LOW	
};
/* The pin used in the ccp2 module */
pin_config_t CCP2_pin = {
	PORTB_I,
	PIN3,
	GPIO_OUT,	
	GPIO_LOW	
};

/* @brief: Initialize the CCP1 module for a selected mode.
 * @param: A pointer to a struct of type CCP1_t specifying the CCP1 module.
 * @return: E_OK upon success and E_NOT_OK otherwise.
 */
STD_ReturnType CCP1_initialize(const CCP1_t * ccp1){
	STD_ReturnType ret = E_OK;
	if(NULL == ccp1)
		ret = E_NOT_OK;
	else{
		/* Turn off the device */
		CCP1_DIS();
		/* Configure the interrupt */
		#if (INT_PR == INT_EN)
		INT_CCP1_init(ccp1 -> priority);
		#elif (INT_PR == INT_DIS)
		INT_CCP1_initialize(1); // Garbage value
		#else 
		ret = E_NOT_OK;
		#endif
		/* Configure the mode */
		/** Capture mode **/
		if(ccp1 -> mode == CCP_Capture){
			/* Configure CCP1 pin as input */
			TRISCbits.RC2=1;
			/* Configure the event-trigger */ 		
			switch(ccp1 -> op_mode.cap.event_trg){
				case(CCP_falling):
					CCP1_CAPTURE_FALL();
					break;
				case(CCP_rising):
					CCP1_CAPTURE_RIS();
					break;
				case(CCP_rising_4th):
					CCP1_CAPTURE_4RIS();
					break;
				case(CCP_rising_16th):
					CCP1_CAPTURE_16RIS();
					break;
				default:
					ret = E_NOT_OK;
					break;
			}  
			/* Configure the Timer */
			switch(ccp1 -> op_mode.cap.timer){
				case(CCP_TMR1):
					ret = ret && TMR1_initialize(&(ccp1 -> op_mode.cap.u_timer));
					break;
				case(CCP_TMR2):
					perror("Cannot use TMR2 in the Capture mode");
					ret = E_NOT_OK;
					break;
				case(CCP_TMR3):
					ret = ret && TMR3_initialize(&(ccp1 -> op_mode.cap.u_timer));
					break;
				default:
					ret = E_NOT_OK;
					break;
			}
		}	
		/** Compare mode **/
		else if(ccp1 -> mode == CCP_Compare){
			/* Configure CCP1 pin as output */
			TRISCbits.RC2=0;
			/* Configure the operation */
			switch(ccp1 -> op_mode.comp.event_trg){
				case(CCP_Low): 
					ret = ret && GPIO_pin_write_logic(&CCP1_pin, GPIO_HIGH);
					CCP1_COMPARE_LOW();
					break;
				case(CCP_High): 
					ret = ret && GPIO_pin_write_logic(&CCP1_pin, GPIO_LOW);
					CCP1_COMPARE_HIGH();
					break;
				case(CCP_Toggle):
					CCP1_COMPARE_TOGG();
					break;
				case(CCP_Unchanged): 
					CCP1_COMPARE_NOP();
					break;
				case(CCP_Special_event): 
					CCP1_COMPARE_SPECIAL();
					break;
				default:
					ret = E_NOT_OK;
					break;
			}
			/* Configure the timer */
			switch(ccp1 -> op_mode.comp.timer){
				case(CCP_TMR1):
					ret = ret && TMR1_initialize(&(ccp1 -> op_mode.comp.timer));
					CCP1_TMR1(); // Need revising for potential flaws when defining another CCPx module
					break;
				case(CCP_TMR2):
					perror("Cannot use TMR2 in the Compare mode");
					ret = E_NOT_OK;
					break;
				case(CCP_TMR3):
					ret = ret && TMR3_initialize(&(ccp1 -> op_mode.cap.u_timer));
					CCP_TMR3();
					break;
				default:
					ret = E_NOT_OK;
					break;
			}
		}
		else{/** PWM mode **/
			/* Set the CCP1 pin for output */
			TRISCbits.RC2=0;
			/* Initialize the Timer2 module */
			ret = ret && TMR2_initialize(&(ccp1 -> op_mode.pwm.timer2));
			/* Set preloaded value in the CCPR1L:DC1B[1-0] bits and PR2 bits */
			PR2 = ((1/(ccp1 -> op_mode.pwm.PWM_freq))/ (4 * (1/_XTAL_FREQ) * (ccp1 -> op_mode.pwm.timer2.prescaler))) - 1;
			uint16 CCP1PR_val = (ccp1 -> op_mode.pwm.PWM_duty_cycle) / ( (ccp1 -> op_mode.pwm.timer2.prescaler) * (1/_XTAL_FREQ));		
			CCPR1L = (uint8) (CCP1PR_val >> 2) ;
			CCP1CONbits.DC1B0 = CCP1PR_val & 0x01;	
			CCP1CONbits.DC1B1 = (CCP1PR_val >> 1) & 0x01;
		}
	}
	return ret;
}

/* @brief: Initialize the CCP2 module for a specified mode.
 * @param: A pointer to a struct of type CCP2_t.
 * @return: E_OK upon success and E_NOT_OK otherwise.
 */
STD_ReturnType CCP2_initialize(const CCP2_t * ccp2){
	STD_ReturnType ret = E_OK;
	if(NULL == ccp2)
		ret = E_NOT_OK;
	else{
		/* Turn off the device */
		CCP2_DIS();
		/* Configure the interrupt */
		#if (INT_PR == INT_EN)
		INT_CCP2_init(ccp2 -> priority);
		#elif (INT_PR == INT_DIS)
		INT_CCP2_initialize(1); // Garbage value
		#else 
		ret = E_NOT_OK;
		#endif
		/* Configure the mode */
		/** Capture mode **/
		if(ccp2 -> mode == CCP_Capture){
			/* Configure CCP2 pin as input */
			TRISBbits.RB3=1;
			/* Configure the event-trigger */ 		
			switch(ccp2 -> op_mode.cap.event_trg){
				case(CCP_falling):
					CCP2_CAPTURE_FALL();
					break;
				case(CCP_rising):
					CCP2_CAPTURE_RIS();
					break;
				case(CCP_rising_4th):
					CCP2_CAPTURE_4RIS();
					break;
				case(CCP_rising_16th):
					CCP2_CAPTURE_16RIS();
					break;
				default:
					ret = E_NOT_OK;
					break;
			}  
			/* Configure the Timer */
			switch(ccp2 -> op_mode.cap.timer){
				case(CCP_TMR1):
					ret = ret && TMR1_initialize(&(ccp2 -> op_mode.cap.u_timer));
					break;
				case(CCP_TMR2):
					perror("Cannot use TMR2 in the Capture mode");
					ret = E_NOT_OK;
					break;
				case(CCP_TMR3):
					ret = ret && TMR3_initialize(&(ccp2 -> op_mode.cap.u_timer));
					break;
				default:
					ret = E_NOT_OK;
					break;
			}
		}	
		/** Compare mode **/
		else if(ccp2 -> mode == CCP_Compare){
			/* Configure CCP2 pin as output */
			TRISBbits.RB3=0;
			/* Configure the operation */
			switch(ccp2 -> op_mode.comp.event_trg){
				case(CCP_Low): 
					ret = ret && GPIO_pin_write_logic(&CCP2_pin, GPIO_HIGH);
					CCP2_COMPARE_LOW();
					break;
				case(CCP_High): 
					ret = ret && GPIO_pin_write_logic(&CCP2_pin, GPIO_LOW);
					CCP2_COMPARE_HIGH();
					break;
				case(CCP_Unchanged): 
					CCP2_COMPARE_NOP();
					break;
				case(CCP_Special_event): 
					CCP2_COMPARE_SPECIAL();
					break;
				default:
					ret = E_NOT_OK;
					break;
			}
			/* Configure the timer */
			switch(ccp2 -> op_mode.cap.timer){
				case(CCP_TMR1):
					ret = ret && TMR1_initialize(&(ccp2 -> op_mode.comp.timer));
					CCP1_TMR1();
					break;
				case(CCP_TMR2):
					perror("Cannot use TMR2 in the Compare mode");
					ret = E_NOT_OK;
					break;
				case(CCP_TMR3):
					ret = ret && TMR3_initialize(&(ccp2 -> op_mode.cap.u_timer));
					CCP_TMR3();
					break;
				default:
					ret = E_NOT_OK;
					break;
			}
		}
		else{/** PWM mode **/
			/* Set the CCP2 pin for output */
			TRISBbits.RB3=0;
			/* Initialize the Timer2 module */
			TMR2_initialize(&(ccp2 -> op_mode.pwm.timer2));
			/* Initialize PR2 and CCPR1L:DC1B[1-0] bits */
			PR2 = ((1/(ccp2 -> op_mode.pwm.PWM_freq))/ (4 * (1/_XTAL_FREQ) * (ccp2 ->op_mode.pwm.timer2.prescaler))) - 1;
			uint16 CCP2PR_val = (ccp2 -> op_mode.pwm.PWM_duty_cycle) / ( (ccp2 -> op_mode.pwm.timer2.prescaler) * (1/_XTAL_FREQ));		
			CCPR2L = (uint8) (CCP2PR_val >> 2) ;
			CCP2CONbits.DC2B0 = CCP2PR_val & 0x01;	
			CCP2CONbits.DC2B1 = (CCP2PR_val >> 1) & 0x01;
		}
	}
	return ret;
}
/* @brief: Deinitialize the CCP1 module.
 * @param: A pointer to a struct of type CCP1_t.
 * @return: E_OK upon success and E_NOT_OK otherwise.
 */
STD_ReturnType CCP1_deinitialize(const CCP1_t * ccp1){
	STD_ReturnType ret = E_OK;
	if(NULL == ccp1)
		ret = E_NOT_OK;
	else{
		/* Turn off the module */
		CCP1_DIS();	
		/* Zero the PR2 and CCPR1L registers */
		PR2 = 0x00;
		CCPR1L = 0x00;
		CCP1CON=0x00; /* reset the CCP1 control register */
		/* Deinitialize the interrupt */
		INT_CCP1_deinit();
	}
	return ret;
}
/* @brief: Deinitialize the CCP2 module.
 * @param: A pointer to a struct of type CCP2_t.
 * @return: E_OK upon success and E_NOT_OK otherwise.
 */
STD_ReturnType CCP2_deinitialize(const CCP2_t * ccp2){
	STD_ReturnType ret = E_OK;
	if(NULL == ccp2)
		ret = E_NOT_OK;
	else{
		/* Turn off the module */
		CCP2_DIS();	
		/* Zero the PR2 and CCPR2L registers */
		PR2 = 0x00;
		CCPR2L = 0x00;
		CCP2CON=0x00; /* reset the CCP2 control register */
		/* Deinitialize the interrupt */
		INT_CCP2_deinit();
	}
	return ret;
}
/* @brief: Set the duty cycle of the CCP1 module working in PWM mode. 
 * @param: A pointer to a struct of type CCP1_t and a uint8 specifying the 
 * 		   duty cycle as a percent (0% - 100%).
 * @return: E_OK upon success and E_NOT_OK otherwise.
 */
STD_ReturnType CCP1_PWM_set_duty_cycle(const CCP1_t * ccp1, uint8 duty_cycle){
	STD_ReturnType ret = E_OK;
	if(ccp1 == NULL|| ccp1 -> mode != CCP_PWM || duty_cycle > 100)
		ret = E_NOT_OK;
	else{
		uint16 CCP1PR_val = (duty_cycle) / ( (ccp1 -> op_mode.pwm.timer2.prescaler) * (1/_XTAL_FREQ));		
		CCPR1L = (uint8) (CCP1PR_val >> 2) ;
		CCP1CONbits.DC1B0 = CCP1PR_val & 0x01;	
		CCP1CONbits.DC1B1 = (CCP1PR_val >> 1) & 0x01;
	}
	return ret;
}
/* @brief: Set the duty cycle of the CCP2 module working in PWM mode. 
 * @param: A pointer to a struct of type CCP2_t and a uint8 specifying the 
 * 		   duty cycle as a percent (0% - 100%).
 * @return: E_OK upon success and E_NOT_OK otherwise.
 */
STD_ReturnType CCP2_PWM_set_duty_cycle(const CCP2_t * ccp2, uint8 duty_cycle){
	STD_ReturnType ret = E_OK;
	if(ccp2 == NULL|| ccp2 -> mode != CCP_PWM || duty_cycle > 100)
		ret = E_NOT_OK;
	else{
		uint16 CCP2PR_val = (duty_cycle) / ( (ccp2 -> op_mode.pwm.timer2.prescaler) * (1/_XTAL_FREQ));		
		CCPR2L = (uint8) (CCP2PR_val >> 2) ;
		CCP2CONbits.DC2B0 = CCP2PR_val & 0x01;	
		CCP2CONbits.DC2B1 = (CCP2PR_val >> 1) & 0x01;
	}
	return ret;
}
/* @brief: Set the PWM frequency for the CCP1 module.
 * @param: A pointer to a struct of type CCP1_t and a uint32 for the frequency.
 * @return: E_OK upon success and E_NOT_OK otherwise.
 */
STD_ReturnType CCP1_PWM_set_frequency(const CCP1_t * ccp1, uint32 freq){
	STD_ReturnType ret = E_OK;
	if(ccp1 == NULL || ccp1 -> mode != CCP_PWM)
		ret = E_NOT_OK;
	else{
		PR2 = ((1/freq)/  (4 * (1/_XTAL_FREQ) * (ccp1 -> op_mode.pwm.timer2.prescaler))) - 1;
	}
	return ret;
}
/* @brief: Set the PWM frequency for the CCP2 module.
 * @param: A pointer to a struct of type CCP2_t and a uint32 for the frequency.
 * @return: E_OK upon success and E_NOT_OK otherwise.
 */
STD_ReturnType CCP2_PWM_set_frequency(const CCP2_t * ccp2, uint32 freq){
	STD_ReturnType ret = E_OK;
	if(ccp2 == NULL || ccp2 -> mode != CCP_PWM)
		ret = E_NOT_OK;
	else{
		PR2 = ((1/freq)/ (4 * (1/_XTAL_FREQ) * (ccp2 -> op_mode.pwm.timer2.prescaler))) - 1;
	}
	return ret;
}
/* @brief: Start the CCP1 timer by starting the corresponding timer. 
 * @param: A pointer to a struct specifying the CCP1 module.
 * @return: E_OK upon success and E_NOT_OK otherwise.
 */
STD_ReturnType CCP1_start(const CCP1_t * ccp1){
	STD_ReturnType ret = E_OK;
	if(NULL == ccp1)
		ret = E_NOT_OK;
	else{
		switch(ccp1 -> mode){
			case(CCP_Capture):
				/* Turn off TMR1 or TMR3 */
				if(ccp1 -> op_mode.cap.timer == TMR1)
					TMR1_ON();
				else if(ccp1 -> op_mode.cap.timer == TMR3)
					TMR3_ON();
				break;
			case(CCP_Compare):
				/* Turn off TMR1 or TMR3 */
				if(ccp1 -> op_mode.comp.timer == TMR1)
					TMR1_ON();
				else if(ccp1 -> op_mode.comp.timer == TMR3)
					TMR3_ON();
				break;
			case(CCP_PWM):
				/* Turn off TMR2 */
				TMR2_ON();
				break;
			default:
				ret = E_NOT_OK;
				break;
		}	
	}
	return ret;
}
/* @brief: Start the CCP2 timer by starting the corresponding timer. 
 * @param: A pointer to a struct specifying the CCP2 module.
 * @return: E_OK upon success and E_NOT_OK otherwise.
 */
STD_ReturnType CCP2_start(const CCP2_t * ccp2){
	STD_ReturnType ret = E_OK;
	if(NULL == ccp2)
		ret = E_NOT_OK;
	else{
		switch(ccp2 -> mode){
			case(CCP_Capture):
				/* Turn off TMR1 or TMR3 */
				if(ccp2 -> op_mode. cap .timer == TMR1)
					TMR1_ON();
				else if(ccp2 -> op_mode.cap.timer == TMR3)
					TMR3_ON();
				break;
			case(CCP_Compare):
				/* Turn off TMR1 or TMR3 */
				if(ccp2 -> op_mode.comp.timer == TMR1)
					TMR1_ON();
				else if(ccp2 -> op_mode.comp.timer == TMR3)
					TMR3_ON();
				break;
			case(CCP_PWM):
				/* Turn off TMR2 */
				TMR2_ON();
				break;
			default:
				ret = E_NOT_OK;
				break;
		}	
	}
	return ret;
}
/* @brief: Stop the CCP1 module by stopping the 
 * 		   timer used in either of the three modes.
 * @param: A pointer to a struct of type CCP1_t.
 * @return: E_OK upon success and E_NOT_OK otherwise.
 */
STD_ReturnType CCP1_stop(const CCP1_t * ccp1){
	STD_ReturnType ret = E_OK;
	if(NULL == ccp1)
		ret = E_NOT_OK;
	else{
		switch(ccp1 -> mode){
			case(CCP_Capture):
				/* Turn off TMR1 or TMR3 */
				if(ccp1 -> op_mode.cap.timer == TMR1)
					TMR1_OFF();
				else if(ccp1 -> op_mode.cap.timer == TMR3)
					TMR3_OFF();
				break;
			case(CCP_Compare):
				/* Turn off TMR1 or TMR3 */
				if(ccp1 -> op_mode.comp.timer == TMR1)
					TMR1_OFF();
				else if(ccp1 -> op_mode.comp.timer == TMR3)
					TMR3_OFF();
				break;
			case(CCP_PWM):
				/* Turn off TMR2 */
				TMR2_OFF();
				break;
			default:
				ret = E_NOT_OK;
				break;
		}	
	}
	return ret;
}
/* @brief: Stop the CCP2 module by stopping the 
 * 		   timer used in either of the three modes.
 * @param: A pointer to a struct of type CCP2_t.
 * @return: E_OK upon success and E_NOT_OK otherwise.
 */
STD_ReturnType CCP2_stop(const CCP2_t * ccp2){
	STD_ReturnType ret = E_OK;
	if(NULL == ccp2)
		ret = E_NOT_OK;
	else{
		switch(ccp2 -> mode){
			case(CCP_Capture):
				/* Turn off TMR1 or TMR3 */
				if(ccp2 -> op_mode.cap.timer == TMR1)
					TMR1_OFF();
				else if(ccp2 -> op_mode.cap.timer == TMR3)
					TMR3_OFF();
				break;
			case(CCP_Compare):
				/* Turn off TMR1 or TMR3 */
				if(ccp2 -> op_mode.comp.timer == TMR1)
					TMR1_OFF();
				else if(ccp2 -> op_mode.comp.timer == TMR3)
					TMR3_OFF();
				break;
			case(CCP_PWM):
				/* Turn off TMR2 */
				TMR2_OFF();
				break;
			default:
				ret = E_NOT_OK;
				break;
		}	
	}
	return ret;
}
